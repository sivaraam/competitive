package org.sivaraam.cassidoo.oct27_2025;

import java.util.*;

/**
 * A variant of the ScareCrowPlacement solution that's greedy and simpler.
 * The key insight is: When we encounter an unprotected position that needs
 * protection, place the scarecrow as far right as possible while still covering
 * that position.
 * <p>
 * <h2>Step-by-Step Algorithm</h2>
 * <ol>
 *     <li>
 *         Find all positions that need protection (where field[i] = 1)
 *     </li>
 *     <li>
 *         Iterate through positions from left to right
 *     </li>
 *     <li>
 *         For each unprotected position that needs protection:
 *         <ol>
 *           <li>
 *               Calculate the rightmost position where we can place a scarecrow
 *               that still covers this position
 *           </li>
 *           <li>
 *               Place the scarecrow there
 *           </li>
 *           <li>
 *               Mark all positions covered by this scarecrow as protected
 *           </li>
 *         </ol>
 *     </li>
 * </ol>
 *
 * <h2>Why Greedy Works?</h2>
 * By placing each scarecrow as far right as possible, we maximize the chance of
 * covering future positions to the right, minimizing total scarecrows needed.
 * <p>
 * <h2>Note</h2>
 * Generated by Claude.
 */
public class ScareCrowGreedyPlacement {

    /**
     * Places scarecrows to protect all positions marked with 1.
     *
     * @param field array of 0s and 1s
     * @param k coverage range (odd numbers provide symmetric coverage)
     *          For even k, coverage is k/2 positions left, the center, and k/2-1 right
     *          e.g., k=4 at position 5 covers [3,4,5,6]
     * @return list of positions where scarecrows should be placed
     */
    public static List<Integer> placeScarecrows(int[] field, int k) {
        List<Integer> scarecrows = new ArrayList<>();
        int n = field.length;
        int radius = k / 2;  // How far the scarecrow reaches on each side

        // Track which positions are already protected
        boolean[] protectedPositions = new boolean[n];

        // Iterate through the field from left to right
        for (int i = 0; i < n; i++) {
            // Skip if this position doesn't need protection or is already protected
            if (field[i] == 0 || protectedPositions[i]) {
                continue;
            }

            // Position i needs protection and isn't protected yet
            // Place scarecrow as far right as possible while still covering i
            int scarecrowPos = Math.min(i + radius, n - 1);

            scarecrows.add(scarecrowPos);

            int leftCoverage;
            int rightCoverage;

            // Mark all positions this scarecrow protects
            if (k % 2 == 1) {
                leftCoverage = Math.max(0, scarecrowPos - radius);
                rightCoverage = Math.min(n - 1, scarecrowPos + radius);
            }
            else {
                leftCoverage = Math.max(0, scarecrowPos - radius);
                rightCoverage = Math.min(n - 1, scarecrowPos + radius - 1);
            }

            for (int j = leftCoverage; j <= rightCoverage; j++) {
                protectedPositions[j] = true;
            }
        }

        return scarecrows;
    }

    public static void main(String[] args) {
        System.out.println(placeScarecrows(new int[]{1, 1, 0, 1, 1, 0, 1}, 3));
        // Output: [1, 4, 6]

        System.out.println(placeScarecrows(new int[]{1, 0, 1, 1, 0, 1}, 3));
        // Output: [1, 4]

        System.out.println(placeScarecrows(new int[]{1, 1, 1, 1, 1}, 1));
        // Output: [0, 1, 2, 3, 4]

        System.out.println(placeScarecrows(new int[]{1, 0, 1, 0, 1}, 2));
        // Output: [1, 4, 6]
    }
}