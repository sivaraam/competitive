import java.math.BigDecimal
import java.math.MathContext
import java.math.RoundingMode

data class TestCase(
    val name: String,
    val input: List<BigDecimal>,
    val expected: BigDecimal,
    val tolerance: BigDecimal = BigDecimal("1E-10")
)

/**
 * A class generated by Claude in order to analyze the failing test
 * cases in the BigDecimal solution and give some details about
 * the failing cases.
 *
 * Retaining it solely for reference purposes.
 */
class NeighborSumBigDecimalTester {

    private val mathContext = MathContext(110, RoundingMode.HALF_UP)

    // BigDecimal solution implementation
    private fun solution(list: List<BigDecimal>): BigDecimal {
        var totalSum = BigDecimal.ZERO

        for (i in 0..list.size-1) {
            var sum = list[i] // The element itself

            // Add left neighbor if it exists
            if (i > 0) {
                sum = sum.add(list[i - 1], mathContext)
            }

            // Add right neighbor if it exists
            if (i < list.size - 1) {
                sum = sum.add(list[i + 1], mathContext)
            }

            totalSum = totalSum.add(sum, mathContext)
        }

        return totalSum
    }

    private fun createTestCases(): List<TestCase> {
        return listOf(
            TestCase(
                name = "Basic Precision",
                input = listOf(
                    BigDecimal("0.1"),
                    BigDecimal("0.2"),
                    BigDecimal("0.3")
                ),
                expected = BigDecimal("1.4"),
                tolerance = BigDecimal("1E-10")
            ),

            TestCase(
                name = "Very Small Numbers",
                input = listOf(
                    BigDecimal("1E-15"),
                    BigDecimal("2E-15"),
                    BigDecimal("3E-15")
                ),
                expected = BigDecimal("1.4E-14"),
                tolerance = BigDecimal("1E-24")
            ),

            TestCase(
                name = "Mixed Very Small and Normal",
                input = listOf(
                    BigDecimal("1E-10"),
                    BigDecimal("0.5"),
                    BigDecimal("1E-10")
                ),
                expected = BigDecimal("1.5000000004"),
                tolerance = BigDecimal("1E-12")
            ),

            TestCase(
                name = "Large Magnitude Differences",
                input = listOf(
                    BigDecimal("1E-15"),
                    BigDecimal("1E15"),
                    BigDecimal("1E-15")
                ),
                expected = BigDecimal("3000000000000000.000000000000004"),
                tolerance = BigDecimal("1E-16")
            ),

            TestCase(
                name = "Psizerecision Loss Scenario",
                input = (1..10).map { BigDecimal("0.1") },
                expected = BigDecimal("2.8"),
                tolerance = BigDecimal("1E-10")
            ),

            TestCase(
                name = "Numbers That Don't Sum Cleanly in Binary",
                input = listOf(
                    BigDecimal("0.1"), BigDecimal("0.2"), BigDecimal("0.3"),
                    BigDecimal("0.4"), BigDecimal("0.5"), BigDecimal("0.6"),
                    BigDecimal("0.7"), BigDecimal("0.8"), BigDecimal("0.9")
                ),
                expected = BigDecimal("12.5"),
                tolerance = BigDecimal("1E-10")
            ),

            TestCase(
                name = "Alternating Tiny and Huge",
                input = listOf(
                    BigDecimal("1E-16"),
                    BigDecimal("1E16"),
                    BigDecimal("1E-16"),
                    BigDecimal("1E16"),
                    BigDecimal("1E-16")
                ),
                expected = BigDecimal("60000000000000000.0000000000000007"),
                tolerance = BigDecimal("1E6")
            ),

            TestCase(
                name = "Near Double Precision Limits",
                input = listOf(
                    BigDecimal("1.7976931348623157E308"),
                    BigDecimal("1E-10"),
                    BigDecimal("-1.7976931348623157E308")
                ),
                expected = BigDecimal("3E-100"),
                tolerance = BigDecimal("1E-110")
            ),

            TestCase(
                name = "Catastrophic Cancellation",
                input = listOf(
                    BigDecimal("1.0000000000000002"),
                    BigDecimal("-1.0"),
                    BigDecimal("1.0000000000000002")
                ),
                expected = BigDecimal("1.0000000000000008"),
                tolerance = BigDecimal("1E-15")
            ),

            TestCase(
                name = "Extreme Precision Challenge",
                input = listOf(
                    BigDecimal("0.123456789012345"),
                    BigDecimal("-0.123456789012344"),
                    BigDecimal("0.000000000000001"),
                    BigDecimal("1E-14"),
                    BigDecimal("-1E-14")
                ),
                expected = BigDecimal("-.123456789012329"),
                tolerance = BigDecimal("1E-16")
            ),

            TestCase(
                name = "Accumulated Rounding Errors",
                input = (1..100).map { BigDecimal("0.01") },
                expected = BigDecimal("2.98"),
                tolerance = BigDecimal("1E-10")
            ),

            TestCase(
                name = "Negative Precision Scenario",
                input = listOf(
                    BigDecimal("-0.1"), BigDecimal("-0.2"), BigDecimal("-0.3"),
                    BigDecimal("-0.4"), BigDecimal("-0.5")
                ),
                expected = BigDecimal("-3.9"),
                tolerance = BigDecimal("1E-10")
            ),

            TestCase(
                name = "Empty List",
                input = emptyList(),
                expected = BigDecimal.ZERO,
                tolerance = BigDecimal("1E-10")
            ),

            TestCase(
                name = "Single Element",
                input = listOf(BigDecimal("5.5")),
                expected = BigDecimal("5.5"),
                tolerance = BigDecimal("1E-10")
            )
        )
    }

    private fun runTest(testCase: TestCase): TestResult {
        return try {
            val actual = solution(testCase.input)
            val difference = testCase.expected.subtract(actual).abs()
            val passed = difference.compareTo(testCase.tolerance) <= 0

            val relativeError = if (testCase.expected.compareTo(BigDecimal.ZERO) != 0) {
                difference.divide(testCase.expected.abs(), mathContext)
            } else {
                BigDecimal.ZERO
            }

            TestResult(
                name = testCase.name,
                passed = passed,
                expected = testCase.expected,
                actual = actual,
                difference = difference,
                tolerance = testCase.tolerance,
                relativeError = relativeError
            )
        } catch (e: Exception) {
            TestResult(
                name = testCase.name,
                passed = false,
                expected = testCase.expected,
                actual = null,
                difference = null,
                tolerance = testCase.tolerance,
                error = e.message
            )
        }
    }

    fun runAllTests(): List<TestResult> {
        val testCases = createTestCases()
        return testCases.map { runTest(it) }
    }

    fun printResults(results: List<TestResult>) {
        println("=".repeat(80))
        println("BigDecimal Precision - Neighbor Sum Test Results")
        println("=".repeat(80))

        var passedCount = 0
        var failedCount = 0

        results.forEach { result ->
            if (result.passed) {
                passedCount++
                println("‚úÖ PASS: ${result.name}")
                if (result.actual != null && result.difference != null) {
                    println("   Expected: ${result.expected.toPlainString()}")
                    println("   Actual:   ${result.actual.toPlainString()}")
                    println("   Diff:     ${result.difference.toEngineeringString()}")
                    if (result.relativeError != null && result.relativeError.compareTo(BigDecimal.ZERO) > 0) {
                        println("   Rel Err:  ${result.relativeError.toEngineeringString()}")
                    }
                }
            } else {
                failedCount++
                println("‚ùå FAIL: ${result.name}")
                println("   Expected: ${result.expected.toPlainString()}")
                println("   Actual:   ${result.actual?.toPlainString() ?: "ERROR"}")
                if (result.difference != null) {
                    println("   Diff:     ${result.difference.toEngineeringString()}")
                    println("   Tolerance: ${result.tolerance.toEngineeringString()}")
                    if (result.relativeError != null) {
                        println("   Rel Err:  ${result.relativeError.toEngineeringString()}")
                    }
                }
                if (result.error != null) {
                    println("   Error:    ${result.error}")
                }
            }
            println()
        }

        println("=".repeat(80))
        println("Summary: $passedCount passed, $failedCount failed, ${results.size} total")
        println("Success Rate: ${"%.1f".format(passedCount.toDouble() / results.size * 100)}%")
        println("=".repeat(80))
    }

    fun analyzeResults(results: List<TestResult>) {
        val failedTests = results.filter { !it.passed }
        val passedTests = results.filter { it.passed }

        println("\nüìä BIGDECIMAL PRECISION ANALYSIS")
        println("=".repeat(50))

        if (passedTests.isNotEmpty()) {
            println("‚úÖ SUCCESSFUL TESTS (${passedTests.size}):")
            passedTests.forEach { result ->
                if (result.difference != null && result.difference.compareTo(BigDecimal.ZERO) > 0) {
                    println("   ${result.name}: diff = ${result.difference.toEngineeringString()}")
                } else {
                    println("   ${result.name}: exact match")
                }
            }
            println()
        }

        if (failedTests.isNotEmpty()) {
            println("‚ùå FAILED TESTS (${failedTests.size}):")
            failedTests.forEach { result ->
                println("üîç ${result.name}")
                println("   Input size: ${getInputSize(result.name)}")

                if (result.actual != null && result.difference != null) {
                    val toleranceRatio = result.difference.divide(result.tolerance, mathContext)
                    println("   Tolerance exceeded by: ${toleranceRatio.toEngineeringString()}x")

                    val ratio = toleranceRatio.toDouble()
                    when {
                        ratio > 1000 -> println("   ‚ö†Ô∏è  SEVERE precision issue - algorithm problem?")
                        ratio > 100 -> println("   ‚ö†Ô∏è  MAJOR precision issue - review implementation")
                        ratio > 10 -> println("   ‚ö†Ô∏è  MODERATE precision issue - check calculations")
                        else -> println("   ‚ÑπÔ∏è  MINOR precision issue - likely acceptable")
                    }
                }
                println()
            }
        } else {
            println("üéâ ALL TESTS PASSED! BigDecimal provides excellent precision.")
        }

        // Statistical summary
        println("üìà PRECISION STATISTICS:")
        val nonZeroDiffs = results.mapNotNull { it.difference }.filter { it.compareTo(BigDecimal.ZERO) > 0 }
        if (nonZeroDiffs.isNotEmpty()) {
            val maxDiff = nonZeroDiffs.maxOrNull()
            val minDiff = nonZeroDiffs.minOrNull()
            println("   Max difference: ${maxDiff?.toEngineeringString() ?: "N/A"}")
            println("   Min difference: ${minDiff?.toEngineeringString() ?: "N/A"}")
        } else {
            println("   All computations were exact (zero difference)")
        }
    }

    private fun getInputSize(testName: String): String {
        return when {
            testName.contains("Empty") -> "0"
            testName.contains("Single") -> "1"
            testName.contains("Accumulated") -> "100"
            testName.contains("Precision Loss") -> "10"
            testName.contains("Binary") -> "9"
            testName.contains("Negative") -> "5"
            testName.contains("Extreme") -> "5"
            else -> "3-5"
        }
    }
}

data class TestResult(
    val name: String,
    val passed: Boolean,
    val expected: BigDecimal,
    val actual: BigDecimal?,
    val difference: BigDecimal?,
    val tolerance: BigDecimal,
    val relativeError: BigDecimal? = null,
    val error: String? = null
)

// Main function to run the tests
fun main() {
    val tester = NeighborSumBigDecimalTester()
    val results = tester.runAllTests()

    tester.printResults(results)
    tester.analyzeResults(results)

    // Additional insights
    println("\nüí° INSIGHTS:")
    val passRate = results.count { it.passed }.toDouble() / results.size * 100
    when {
        passRate == 100.0 -> {
            println("   üèÜ Perfect! BigDecimal handles all precision challenges excellently.")
            println("   üí™ Consider using BigDecimal for production code requiring high precision.")
        }
        passRate >= 90 -> {
            println("   üëç Excellent! BigDecimal handles most precision challenges well.")
            println("   üîç Review failed tests to understand remaining edge cases.")
        }
        passRate >= 75 -> {
            println("   ‚ö†Ô∏è  Good, but some precision issues remain.")
            println("   üîß Consider reviewing BigDecimal configuration (scale, rounding mode).")
        }
        else -> {
            println("   ‚ùå Significant precision issues detected.")
            println("   üêõ Review implementation - there may be algorithmic problems.")
        }
    }
}